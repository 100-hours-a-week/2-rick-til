## 1)JDK와 JRE

![노트 2024. 4. 32.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/854c3613-24b6-410f-9982-dfa5aacd905c/c53f6afb-c621-4fb6-85af-78b16ab76bdd/%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3_2024._4._32.jpeg)

### JDK(Java Development Kit)

  자바 개발을 위한 **도구**의 모음
  Java 컴파일러, 디버거, JVM 등을 포함

### JRE(Java Runtime Environment)

  자바 실행을 위한 **환경**

  JDK내부에 포함되어 있으며, 독립적으로 설치 가능

---

### 컴파일러(Compiler)

  Java의 컴파일러는 javac라고 하며, 
  Java로 작성된 소스코드를 Byte Code로 바꾸는 역할

  Byte Code는 Java와 기계어의 중간 언어 정도로 생각하면 된다.

### 디버거(Debugger)

### JavaDoc

  소스 코드에 작성된 주석을 기반으로 HTML 형식의 API 문서를 자동으로 생성해주는 도구

- JavaDoc 태그
    - `@param`: 메서드의 매개변수를 설명할 때 사용합니다.
    - `@return`: 메서드의 반환값을 설명할 때 사용합니다.
    - `@throws` 또는 `@exception`: 메서드가 던질 수 있는 예외를 설명할 때 사용합니다.
    - `@author`: 클래스의 저자를 명시할 때 사용합니다.
    - `@version`: 클래스의 버전을 명시할 때 사용합니다.
    - `@see`: 관련된 클래스나 메서드를 참조할 때 사용합니다.
    - `@deprecated`: 더 이상 사용되지 않는 클래스나 메서드를 표시할 때 사용합니다.
    
    **예시**
    
    ```java
    /**
     * 간단한 계산기를 나타내는 클래스입니다.
     * 
     * @author 홍길동
     * @version 1.0
     * @see java.lang.Math
     */
    public class Calculator {
    
        /**
         * 두 정수를 더합니다.
         *
         * @param a 첫 번째 정수
         * @param b 두 번째 정수
         * @return 두 정수의 합
         */
        public int add(int a, int b) {
            return a + b;
        }
    
        /**
         * 두 정수를 나눕니다.
         *
         * @param a 분자
         * @param b 분모
         * @return 두 정수의 나눗셈 결과
         * @throws ArithmeticException 분모가 0일 경우 던져집니다.
         */
        public double divide(int a, int b) throws ArithmeticException {
            if (b == 0) {
                throw new ArithmeticException("분모는 0일 수 없습니다.");
            }
            return (double) a / b;
        }
    
        /**
         * 이 메서드는 더 이상 사용되지 않습니다.
         *
         * @deprecated use {@link #add(int, int)} 대신 사용하세요.
         */
        @Deprecated
        public int oldAddMethod(int a, int b) {
            return a + b;
        }
    }
    
    ```
    

## 2) 자바의 컴파일과 런타임

![노트 2024. 4. 33.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/854c3613-24b6-410f-9982-dfa5aacd905c/0e6e68cf-91a8-4a10-9e2b-47e44e7de2cc/%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3_2024._4._33.jpeg)

## 2-1)컴파일

### 정의

  JDK에 포함된 자바 컴파일러(javac)를 통해 Java Source(`.java`)를 
  Byte Code(`.class`)로 변환하는 과정을 의미

 소스 코드의 구문 분석, 타입 검사, 바이트코드 생성 등의 단계가 포함됨

### 작동 과정

1. **소스코드 작성**
2. **컴파일러(javac) 실행**
3. **컴파일 단계**
    1. **랙시컬 분석**
        - **역할**
            
            소스 코드를 **토큰(token)** 단위로 분리함 
            토큰은 키워드, 식별자, 연산자, 구분자 등으로 구성된다
            
        - **예제**
            
            `public class HelloWorld { ... }`는 
            `public`, `class`, `HelloWorld`, `{`, `}` 등의 토큰으로 분리됨
            
    2. **파싱**
        - **역할**
            
            렉시컬 분석을 통해 생성된 토큰을 기반으로 
            **구문 트리(parse tree)** 또는 **추상 구문 트리(Abstract Syntax Tree, AST)**를 생성
            이는 코드의 구조와 문법적 의미를 분석하는 단계
            
        - **목적**
            
            코드가 Java 문법에 맞는지 검증하고, 구문 오류를 발견합니다.
            
    3. **의미 분석**
        - **역할**
            
            AST를 기반으로 **타입 검사**와 **심볼 테이블(symbol table)** 검증을 수행
            변수의 타입, 메서드의 시그니처, 접근 제어자 등을 확인합니다.
            
        - **목적**
            
            타입 불일치, 잘못된 변수 사용, 접근 제어 위반 등의 의미적 오류를 검출
            
    4. **최적화**
        - **역할**
            
            컴파일러는 코드를 최적화하여 더 효율적인 바이트코드를 생성
            이는 성능 향상이나 코드 크기 감소를 목표로 함
            
        - **예제**
            
            불필요한 코드 제거, 루프 최적화, 인라인 확장 등이 포함될 수 있습니다.
            
    5. **Byte Code 생성**
        - **역할**
            
            최적화된 AST를 기반으로 **Byte Code**를 생성
            바이트코드는 JVM에서 실행될 수 있는 중간 코드 형식을 말함
            
        - **결과**
            
            `.class` 파일이 생성됨
            
4. **Byte Code 실행**
생성된 `.class` 파일은 JVM(Java Virtual Machine)에 의해 실행

## 2-2) 런타임

### 정의

  컴파일 과정을 거쳐 생성된 Byte Code(`.class`) 파일을 
  기계어 코드(OS별 다름)로 변경 후 **JVM을 통해**
  해당 코드를 실행하는 과정을 의미

### 작동 과정

1. Class Loader에 의해 컴파일된 Byte Code를 Runtime Data Area에 저장
2. 실행 엔진을 통해 실행
    
    인터프리터를 이용하여 Byte Code를 한줄씩 기계어로 해석해서 실행하거나,
    JIT 컴파일러를 통해 Byte Code 전체를 기계어로 변환하여 실행
    
3. 실행 중 Runtime Data Area의 데이터 영역을 참조
4. 가비지 컬렉터가 사용하지 않는 인스턴스를 제거하며 메모리관리
5. 위를 반복

## 3) JVM(Java Virtual Machine)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/854c3613-24b6-410f-9982-dfa5aacd905c/575ceb31-579d-4c64-898d-5b230ca26e5b/image.png)

### 정의

  기계어로 번역된 코드를 실행하는데 필요한 **가상 머신을 제공**하는 소프트웨어

### 핵심 구성요소

1. **Class Loader**
    
    컴파일된 바이트 코드(`.class`파일)를 가지고 옴
    
2. **Runtime Data Area**
    
    가지고온 Btye Code를 메모리에 올림
    
3. **Excution Engine**
    
    실행
    

## 3-1) Class Loader

### 역할

  컴파일된 `.class`파일을 찾아서 메모리에 로드하는 역할
  Javac을 통해 컴파일된 Byte Code를 **Runtime Data Area**로 적재합니다.

### 특징

  JVM에서 실행에 필요한 모든 `.class`파일을 한번에 메모리에 올려놓지 않고
  필요한 시점에 동적으로 메모리에 올리는 기술을 사용하는데,
  이를 **동적 로딩(Dynamic Loading)**이라고 함

### 수행 과정

  Runtime Data Area에 적재하는데 3가지 과정으로 구분됨

1. **로딩**
    
    바이트 코드 형태인 `.class` 파일을 찾아 메모리에 로드
    
2. **링크**
    
    로딩된 `.class` 파일을 JVM에서 실행할 수 있도록
    검증(안전한지),
    준비(변수와 기본값을 위한 메모리),
    해석(실제 메모리 주소로 변환),
    과정을 거쳐 실행될 준비를 마침
    
3. **초기화**
    
    클래스 및 정적 코드 블록(바로 실행해도 문제없는 코드들)을 실행
    

## 3-2) Runtime Data Area

![노트 2024. 4. 34.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/854c3613-24b6-410f-9982-dfa5aacd905c/ecd316a0-163f-4a15-8608-90a920629e25/%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3_2024._4._34.jpeg)

### 역할

  JVM이 프로그램 실행 중에 데이터를 저장하고 관리하는 메모리 영역

  JVM도 하나의 가상영역(OS위에 메모리영역에서 돌아감)

### 구성 요소

- **Method Area (메소드 영역)**
    - **역할**
        
        클래스 정보, 필드 및 메서드 데이터 등을 저장
        
    - **특징**
        
        모든 스레드가 공유하며, 클래스 로딩 시 초기화됨
        
- **Heap (힙)**
    - **역할**
        
        프로그램에서 생성된 모든 객체와 배열을 저장
        
    - **특징**
        
        JVM 전체에서 공유되며, 가장 큰 메모리 영역.
        고정되어 있지 않고 확장되거나 축소되거나 함
        
        사용되지 않는 인스턴스는
        가비지 컬렉션(Garbage Collection)이 제거
        
- **JVM Stacks (JVM 스택 영역)**
    - **역할**
        
        스레드가 생성될 때 같이 생성되어,
        스레드가 메서드를 사용할 때마다
        메서드 호출과 관련된 정보를 저장한다
        
        매개변수, 지역변수, 변수의 주소값 등이 이에 해당한다
        
    - **특징**
        
        스레드 안에서 메서드가 실행되면
        스택영역 안에서 스택 프레임이란 것을 만들어
        해당 메서드에 관한 변수를 저장
        메서드가 종료되면 해당 스택프레임을 제거
        
        - **요약도**
            
            ![노트 2024. 4. 34.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/854c3613-24b6-410f-9982-dfa5aacd905c/66431004-4308-4920-9e7c-8e29703cb1c1/%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3_2024._4._34.jpeg)
            
- **PC Register (프로그램 카운터 레지스터)**
    - **역할**
        
        현재 실행 중인 명령어의 주소를 저장
        
    - **특징**
        
        각 스레드마다 별도의 PC 레지스터를 가진다.
        각 스레드가 어떤 부분(코드)을 어떤 명령(CPU)으로 실행해야 할지 관리하고 기록
        
- **Native Method Stack (네이티브 메소드 스택)**
    - **역할**
        
        네이티브 메서드(예: C/C++로 작성된 메서드)를 호출할 때 사용됨
        
    - **특징**
        
        JVM 스택 영역과 유사하지만, JVM 외부에서 관리됩니다
        

### 작동 방식

1. **객체 생성**
    
    `new` 키워드를 사용하여 객체를 생성하면, **힙 영역**에 메모리가 할당됩니다.
    
2. **메서드 호출**
    
    메서드를 호출하면, 자바 스택에 새로운 스택 프레임이 생성됨
     이 프레임에는 메서드의 지역 변수와 연산 스택이 포함됨
    
3. **메모리 접근**
    
     클래스의 필드나 메서드는 Method 영역에서 관리되며,
     힙에 있는 객체는 JVM 스택영역에서 참조
    
4. **가비지 컬렉션**
    
    힙 영역에서 더 이상 참조되지 않는 객체는 가비지 컬렉터에 의해 자동으로 제거
    

+번외
배열은 어디 저장될까?

→ 힙영역에 String Pool이란 공간이 생김

연관 면접 질문: String a = “” /  String a = new String(“”)의 차이점을 JVM관점에서 설명

## 3-3) Excution Engine

### 역할

  실행 엔진은 바이트 코드를 실행하는 역할을 담당

  엔진은 자바 클래스가 JVM에 로드된 이후에 
  Byte Code를 실제 기계어로 OS에 맞게 변환하고 
  Runtime Data Area에서 필요한 데이터를 가져와 실행

### 구성요소

1. **인터 프리터(Interpreter)**
    
     Byte Code를 한 줄씩 읽고, 즉시 실행하는 방식으로 작동
    
    이 방법은 간단하고 구현하기 쉬우나, 
    같은 코드를 반복해서 실행할 때마다 
    매번 다시 변환해야 하므로 실행 속도가 느리다
    
    이러한 단점은 JIT 컴파일러의 도입으로 많은 보완됨.
    
2. **JIT 컴파일러(Just-In-Time Compliler)**
    
    실행 중인 애플리케이션의 반복적으로 실행되는 부분을 감지하여, 
    그 부분만 기계어로 미리 컴파일해서 성능을 올림
    
3. **가비지 컬렉터(Garbage Collector)**
    
    가비지 컬렉터는 힙 메모리 영역에서 더 이상 참조되지 않는 객체들을
    자동으로 검출하고 제거
    
    이 과정은 메모리를 효율적으로 관리하며, 메모리 누수와 같은 문제를 
    방지하는 데 중요한 역할을 한다
    
    ### 심화
    
    그럼 가비지 컬렉터는 무조건 좋을까?
    
    가비지 컬렉터가 동작하는 것도 자원을 필요(성능에 영향)
    
    STW현상: GC를 수행하기위해 JVM이 프로그램 성능을 멈추는 현상,
    이 시간을 최소화 하는것이 관건
    
    해결 방안: 가비지 컬렉터도 튜닝 가능
    

### **인터프리팅 vs JIT 컴파일**

- **인터프리터(Interpreter):**
    - 바이트코드를 한 줄씩 읽고 즉시 실행
    - 초기 실행 속도가 느릴 수 있지만, 
    전체 코드가 한번에 번역되지 않으므로 
    메모리 사용량이 적음
- **JIT 컴파일러(Just-In-Time Compiler):**
    - 자주 실행되는 바이트코드 블록을 **기계어**로 변환하여 캐시에 저장
    - 이미 컴파일된 코드는 빠르게 실행되므로, 인터프리터의 단점을 보완 가능
- **하이브리드 접근**
    
    대부분의 현대 JVM은 인터프리팅과 JIT 컴파일을 조합하여, 
    초기 실행 속도와 장기적인 성능을 모두 최적화하는 방식을 채택
    

컴파일언어와 인터프리터 언어의차이점 찾기

Java는 컴파일언어? 인터프리터 언어?

Java가 실행되면 일어나는 일들

1. JVM이 OS로부터 메모리를 할당 받고 JVM은 할당 받은 메모리를 여러 영역으로 나누어서 관리
2. 컴파일러 소스코드 읽어 들여서 바이트 코드로 전환
3. 클래스로더를 통해 바이트 코드 파일을 JVM으로 로딩
4. 로딩 클래스 파일들은 어떻게 될까? → 실행 엔진에서 실행
5. 해석된 바이트 코드는 메모리에 배치가 되어있고 수행이 이루어 진다. 
수행되는 과정에 GC가 동작
